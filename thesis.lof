\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\contentsline {figure}{\numberline {3.1}{\ignorespaces The Nefertiti model with prescribed seams is UV mapped by our algorithm. Each chart is bijective mapped into a circle or ring with Tutte's embedding and achieves minimal distortion in less than a second. The layout is further improved interactively and the final parametrized model is shown on the right. Our approach guarantees a valid UV map with no inverted elements or overlapping triangles. See the attaching video for the optimization and manual interaction. \relax }}{20}{figure.caption.8}%
\contentsline {figure}{\numberline {3.2}{\ignorespaces The initial mesh $\Mesh $ (in green, left), is embedded in another mesh $D$ (in gray, middle) that covers a box in the ambient space and contains the same triangles as $\Mesh $. $D$ might contain additional points (orange). We denote the triangles that are in $D$ but not in $\Mesh $ as the scaffold $S$. Our algorithm deforms $D$, inducing a corresponding deformation on $\Mesh $ (right), while keeping the boundary (blue vertices) fixed and preventing changes in the triangle orientation.\relax }}{23}{figure.caption.9}%
\contentsline {figure}{\numberline {3.3}{\ignorespaces Different values of $\lambda $ do not affect the result, but they change the number of iterations needed. From left to right: we used a large weight (100x ours), our weight, and a small weight (0.01x ours). The optimization took 9,7, and 8 iterations, respectively, to reach the same energy level.\relax }}{25}{figure.caption.10}%
\contentsline {figure}{\numberline {3.4}{\ignorespaces A bijective map from a circle (left) to a spiral (right) is computed without (top) and with (bottom) the iterative remeshing step. The slivers in the triangulation locks the optimization (top), preventing it from reaching the target shape. \relax }}{26}{figure.caption.11}%
\contentsline {figure}{\numberline {3.5}{\ignorespaces Two models are cut using \citep {Bommes:2009} and bijectively parametrized using our algorithm. See the additional material for more examples.\relax }}{28}{figure.caption.12}%
\contentsline {figure}{\numberline {3.6}{\ignorespaces We compare the distortion energy with respect to the number of iterations on a set of Lucy's meshes with different resolutions (from 1 to 12 million faces). In the center of the plot, we show the 1M Lucy model parametrized by our algorithm. \relax }}{29}{figure.caption.13}%
\contentsline {figure}{\numberline {3.7}{\ignorespaces A mesh is cut by an artist into a single chart and parametrized using SLIM \cite {rabinovich2017scalable} (left) and with our algorithm (right). Note that local-injectivity is not sufficient for this model, since the global overlaps in the highlighted region prevent this parametrization from being a UV texture map. Our result (right) is guaranteed to be bijective.\relax }}{30}{figure.caption.14}%
\contentsline {figure}{\numberline {3.8}{\ignorespaces A model with multiple chart (left) is automatically parametrized in a texture atlas (bottom-right) by first mapping each component to a circle (top-right) and then minimizing the distortion.\relax }}{31}{figure.caption.15}%
\contentsline {figure}{\numberline {3.9}{\ignorespaces We remove the self-intersections from a genus 0 model using the conformalized flow \cite {Kazhdan:2012,Sacht:2013}. The flow is inverted, while using our algorithm to compute a bijective volumetric map, to recover a self-intersection free version of the original surface. The final model can now be meshed using TetGen, since it is free from self-intersections.\relax }}{32}{figure.caption.16}%
\contentsline {figure}{\numberline {3.10}{\ignorespaces We grow a bunny inside a box, while preventing self-intersections. We show the result after 0,10,20,30,40, and 50 iterations.\relax }}{32}{figure.caption.17}%
\contentsline {figure}{\numberline {3.11}{\ignorespaces We repeat the challenging test in \citep {Smith:2015} with a subdivided version of their Hilbert curve to increase the triangle count. Our method starts from a disc (upper left), gracefully extends (upper right), and reaches the same minimum (lower left) in 39 minutes whereas \citep {Smith:2015} didn't terminate more than 5 days (lower right), highlighting our performance boost of over 200 times. \relax }}{33}{figure.caption.18}%
\contentsline {figure}{\numberline {3.12}{\ignorespaces We apply our algorithm on 4 models used in \citep {Smith:2015} (using the same stopping criteria) obtaining visually identical results. Distortion errors produced by our algorithm (outer) and theirs (inner) are shown in black. \relax }}{34}{figure.caption.19}%
\contentsline {figure}{\numberline {3.13}{\ignorespaces A single iteration of our algorithm (from left to right) drastically reduces the distortion. The black vector in the center is \nobreakspace {}150 times longer than the average edge length of its 1-ring. Iterative methods would need thousands of iterations to achieve a similar progress.\relax }}{35}{figure.caption.20}%
\contentsline {figure}{\numberline {3.14}{\ignorespaces Our algorithm is independent to the initial orientation. We rotate the initializing Tutte's mapping of the camel model and obtain results with similar isometric distortion.\relax }}{36}{figure.caption.21}%
\addvspace {10\p@ }
\contentsline {figure}{\numberline {4.1}{\ignorespaces A low-quality mesh with boundary conditions (a) is remeshed using our shell (b) to maintain a bijection between the input and the remeshed output. The boundary conditions (arrows in (a)) are then transferred to the high-quality surface (c), and a non-linear elastic deformation is computed on a volumetric mesh created with TetGen (e). The solution is finally transferred back to the original geometry (d). Note that in this application setting both surface and volumetric meshing can be hidden from the user, who directly specifies boundary conditions and analyses the result on the input geometry.\relax }}{38}{figure.caption.23}%
\contentsline {figure}{\numberline {4.2}{\ignorespaces Overview of our algorithm. We start from a triangle mesh, find directions of extrusion, build the shell, and optimize to simplify it.\relax }}{40}{figure.caption.24}%
\contentsline {figure}{\numberline {4.3}{\ignorespaces Example of the top (left, outer) and bottom (right, inner) surface of the prismatic shell.\relax }}{41}{figure.caption.25}%
\contentsline {figure}{\numberline {4.4}{\ignorespaces A prism $\Delta $ (left) is decomposed into 6 tetrahedra (middle, for clarity, we only draw the 3 tetrahedra of the top slab). Each tetrahedron has a constant vector field in its interior (pointing toward the top surface), which is parallel to the only pillar of the prism that contains the point.\relax }}{42}{figure.caption.26}%
\contentsline {figure}{\numberline {4.5}{\ignorespaces A point $p$ (left) is traced through $\mathcal {V}$ inside the top part of the shell. A ray with $p$ as origin and $\mathcal {V}$ as direction is cast inside the orange tetrahedron (middle). The procedure is repeated (on the blue tetrahedron) until the ray hits a point in the middle surface (right).\relax }}{43}{figure.caption.27}%
\contentsline {figure}{\numberline {4.6}{\ignorespaces A 2D illustration for the normal dot product condition. The blue arrows agrees with the background vector field (white arrows), while the red arrows do not agree.\relax }}{43}{figure.caption.28}%
\contentsline {figure}{\numberline {4.7}{\ignorespaces The composition $\mathcal {P}^{-1}_{\mathcal {S}_2}(\mathcal {P}_{\mathcal {S}_1}(x))$ with $x \in \mathcal {S}_1$, of a direct and an inverse projection operator defines a bijection between two sections $\mathcal {S}_1$ and $\mathcal {S}_2$.\relax }}{44}{figure.caption.29}%
\contentsline {figure}{\numberline {4.8}{\ignorespaces The vector field aligned with the pillar edge (orange) has a negative dot product with the green triangle normal; the tetrahedron with this field direction meets the green triangle at the red vertex. As a consequence, the mid-surface is not a section. After topological beveling, the shell becomes valid since the dot product between the green normal and the new pillar (purple) is positive. \relax }}{47}{figure.caption.30}%
\contentsline {figure}{\numberline {4.9}{\ignorespaces The beveling patterns used to decompose prisms for which $\mathcal {T}$ is not a section.\relax }}{47}{figure.caption.31}%
\contentsline {figure}{\numberline {4.10}{\ignorespaces Our algorithm refines the input model (left) with beveling patterns (middle) to ensure the generation of a valid shell. The subsequent shell optimizations gracefully remove the unnecessary vertices (right).\relax }}{48}{figure.caption.32}%
\contentsline {figure}{\numberline {4.11}{\ignorespaces Different local operations used to optimize the shell. Mesh editing operations translate naturally to the shell setting. For vertex smoothing, we decompose the operation into 3 intermediate steps: pan, zoom, and rotate.\relax }}{49}{figure.caption.33}%
\contentsline {figure}{\numberline {4.12}{\ignorespaces A model with 48 singularities and a close up around one (left). Our shell is pinched around each of them without affecting other regions (right).\relax }}{51}{figure.caption.34}%
\contentsline {figure}{\numberline {4.13}{\ignorespaces Left to right: examples of a singularity as a feature point and as a meshing artefact; and illustration of the degenerate prism with a singularity (red) and its tetrahedral decomposition made of only four tetrahedra.\relax }}{52}{figure.caption.36}%
\contentsline {figure}{\numberline {4.14}{\ignorespaces $AA'$ is a direction with positive dot product with respect to all its neighboring faces. However, no valid shell can be built following that direction.\relax }}{53}{figure.caption.37}%
\contentsline {figure}{\numberline {4.15}{\ignorespaces An example of a mesh with boundary.\relax }}{54}{figure.caption.38}%
\contentsline {figure}{\numberline {4.16}{\ignorespaces The effect of different target thickness on the number of prisms |F| of the final shell, and distribution of final thickness (shown as the box plots on the top).\relax }}{54}{figure.caption.39}%
\contentsline {figure}{\numberline {4.17}{\ignorespaces Gallery of shells built around models from Thingi10k \cite {zhou2016thingi10k} and ABC\nobreakspace {}\cite {koch2019abc}.\relax }}{55}{figure.caption.40}%
\contentsline {figure}{\numberline {4.18}{\ignorespaces Statistics of 5018 shells in Thingi10k dataset \citep {zhou2016thingi10k} (left) and 5545 in ABC Dataset \citep {koch2019abc} (right).\relax }}{56}{figure.caption.41}%
\contentsline {figure}{\numberline {4.19}{\ignorespaces The \emph {UV based method} cannot simplify the prescribed seams, and introduces self-intersections. The projection induced by the \emph {Naive Cage} method is not continuous and not bijective; it leads to visible spikes in the reconstructed geometry.\relax }}{57}{figure.caption.42}%
\contentsline {figure}{\numberline {4.20}{\ignorespaces Our projection is three orders of magnitude more accurate than the baseline method, and bijectively reconstructs the input vertex coordinates.\relax }}{58}{figure.caption.43}%
\contentsline {figure}{\numberline {4.21}{\ignorespaces We attempt to simplify \emph {rockerarm} (top left) from 20088 triangles to 100. QSlim\nobreakspace {}\citep {garland1998simplifying} succeeds in reaching the target triangle count (top right) but generates an output with a self-intersection (red) and flipped triangles (purple). With our shell constraints (bottom left), the simplification stagnates at 136 triangles, but the output is free from undesirable geometric configurations. Note that both examples use the same quadratic error metric based sceduling\nobreakspace {}\citep {garland1998simplifying}. \relax }}{59}{figure.caption.44}%
\contentsline {figure}{\numberline {4.22}{\ignorespaces The heat method (right top) produces inaccurate results due to a poor triangulation (left top). We remesh the input with our method (left bottom), compute the solution of the heat method\nobreakspace {}\citep {crane2013geodesics} on the high-quality mesh (middle bottom) and transfer the solution back to the input mesh using the bijective projection (bottom right). This process produces a result closer to the exact discrete geodesic distance \citep {mitchell1987discrete} (top middle, error shown in the histograms).\relax }}{60}{figure.caption.45}%
\contentsline {figure}{\numberline {4.23}{\ignorespaces \emph {Knot} simplified with our method and tetrahedralized with TetGen. The original model is converted to 1,503,428 tetrahedra (left) while the simplified surface is converted to only 176,190 tetrahedra (right).\relax }}{61}{figure.caption.46}%
\contentsline {figure}{\numberline {4.24}{\ignorespaces The union of two meshes is coarsened through our algorithm, while preserving the exact correspondence, as shown through color transfer.\relax }}{62}{figure.caption.47}%
\contentsline {figure}{\numberline {4.25}{\ignorespaces Top: an input mesh decimated to create a coarse base mesh, and the details are encoded in a displacement map (along the normal) with correspondences computed with Phong projection \citep {kobbelt1998interactive}. Bottom: the decimation is done within our shell while using the same projection as above. With our construction, this projection becomes bijective (Appendix \ref {app:bilinear}), avoiding the artifacts visible on the ears of the bunny in the top row.\relax }}{63}{figure.caption.48}%
\contentsline {figure}{\numberline {4.26}{\ignorespaces Two volumetric chainmail textures (right) are applied to a shell (bottom left) constructed from the \emph {Animal} mesh (top left). The original UV coordinates are transferred using our projection operator.\relax }}{63}{figure.caption.49}%
\contentsline {figure}{\numberline {4.27}{\ignorespaces An example of a shell built around a self-intersecting mesh.\relax }}{64}{figure.caption.50}%
\contentsline {figure}{\numberline {4.28}{\ignorespaces The \emph {Armadillo} model with four nested cages. We create a shell from the original mesh, and then rerun our algorithm on the outer shell to create the other three layers. Note that all layers are free of self-intersections, and we have an explicit bijective map between them.\relax }}{64}{figure.caption.51}%
\contentsline {figure}{\numberline {4.29}{\ignorespaces After optimization, the shell may self-intersect (left). Our postprocessing can be used to extract a non-selfintersecting shell, which is easier to use in downstream applications (right).\relax }}{65}{figure.caption.52}%
\contentsline {figure}{\numberline {4.30}{\ignorespaces We generate a pinched shell for a model with a singularity (left). Optionally, we can complete the shell using our Boolean construction.\relax }}{65}{figure.caption.53}%
\addvspace {10\p@ }
\contentsline {figure}{\numberline {5.1}{\ignorespaces Our pipeline starts from a dense \emph {linear} mesh with annotated features (green), which is converted in a curved shell filled with a high-order mesh. The region bounded by the shell is then tetrahedralized with linear elements, which are then optimized. Our output is a coarse, yet accurate, curved tetrahedral mesh ready to be used in FEM based simulation. Our construction provides a bijective map between the input surface and the boundary of the output tetrahedral mesh, which can be used to transfer attributes and boundary conditions.\relax }}{68}{figure.caption.54}%
\contentsline {figure}{\numberline {5.2}{\ignorespaces Input triangle mesh $\mathcal {M}$ and points $\mathcal {P}$. Output curved tetrahedral mesh $\mathcal {T}^k$ and bijective map $\phi ^k$.\relax }}{70}{figure.caption.55}%
\contentsline {figure}{\numberline {5.3}{\ignorespaces Lagrange nodes on the reference element $\hat \tau $ for different $k=1,2,3$ and example of geometric mapping $g$.\relax }}{70}{figure.caption.56}%
\contentsline {figure}{\numberline {5.4}{\ignorespaces Effect of the choice of the set $\mathcal {P}$ on the output.\relax }}{71}{figure.caption.57}%
\contentsline {figure}{\numberline {5.5}{\ignorespaces Our algorithm maintains {free of} intersection even on challenging models, without the need of setting adaptive threshold.\relax }}{72}{figure.caption.58}%
\contentsline {figure}{\numberline {5.6}{\ignorespaces Overview of curved mesh generation pipeline.\relax }}{72}{figure.caption.59}%
\contentsline {figure}{\numberline {5.7}{\ignorespaces A model simplified with different distances.\relax }}{74}{figure.caption.60}%
\contentsline {figure}{\numberline {5.8}{\ignorespaces Two dimensional overview of the five steps of our boundary preserving tetrahedral meshing algorithm.\relax }}{75}{figure.caption.61}%
\contentsline {figure}{\numberline {5.9}{\ignorespaces Input triangle mesh with features and output curved mesh with feature preserved equipped with bijective map $\phi ^k$.\relax }}{77}{figure.caption.62}%
\contentsline {figure}{\numberline {5.10}{\ignorespaces A sphere with different marked features (green). As we increase the number of features our algorithm will preserve them all but the quality of the surface suffers.\relax }}{78}{figure.caption.63}%
\contentsline {figure}{\numberline {5.11}{\ignorespaces Input feature (green) is not preserved after traditional shell simplification.\relax }}{78}{figure.caption.64}%
\contentsline {figure}{\numberline {5.12}{\ignorespaces Overview of the construction of the first stage of our pipeline.\relax }}{78}{figure.caption.65}%
\contentsline {figure}{\numberline {5.13}{\ignorespaces The input mesh has feature edges snapped, to create a valid shell, as well as the curved mesh.\relax }}{79}{figure.caption.66}%
\contentsline {figure}{\numberline {5.14}{\ignorespaces The input edges feature (green) are grouped together in poly-lines and categorized in graph (left) and loops (right). For every graph we add the nodes (blue) to the set of feature vertices.\relax }}{79}{figure.caption.67}%
\contentsline {figure}{\numberline {5.15}{\ignorespaces Illustration of smoothing on a feature.\relax }}{80}{figure.caption.68}%
\contentsline {figure}{\numberline {5.16}{\ignorespaces Curved meshes of different order. The additional degrees of freedom allows for more coarsening.\relax }}{81}{figure.caption.69}%
\contentsline {figure}{\numberline {5.17}{\ignorespaces Relative average edge length (with respect to longest bounding box edge of each model) of our curved meshes versus number of input vertices.\relax }}{82}{figure.caption.70}%
\contentsline {figure}{\numberline {5.18}{\ignorespaces Within the same distance bound ($10^{-3}$ of the longest bounding box side), our method generates a coarser high order mesh, compared to the linear counterpart generated by fTetWild.\relax }}{82}{figure.caption.71}%
\contentsline {figure}{\numberline {5.19}{\ignorespaces Surface and volume average MIPS energy of the output of our method (the CAD volume energy is truncated at 100, excluding 6 models).\relax }}{83}{figure.caption.72}%
\contentsline {figure}{\numberline {5.20}{\ignorespaces Timing of our algorithm versus the input number of vertices.\relax }}{83}{figure.caption.73}%
\contentsline {figure}{\numberline {5.21}{\ignorespaces Compared with Curved ODT, our method does not rely on setting vertex number and sizing field, and can generate coarse valid results.\relax }}{84}{figure.caption.74}%
\contentsline {figure}{\numberline {5.22}{\ignorespaces Example of a BRep meshed with Gmsh where the optimization fails to untangle elements when fixing the surface. By allowing the surface to be modified, the mesh becomes ``wiggly''. Our method successfully generate a positive curved mesh.\relax }}{85}{figure.caption.75}%
\contentsline {figure}{\numberline {5.23}{\ignorespaces Example of a STEP file meshed with Gmsh where, due to the low mesh density, the tetrahedralization is not positive. Gmsh manages to generate a positive mesh by using a denser initial tessellation. Since our method starts from a dense mesh and coarsen it, it can successfully resolve the geometry.\relax }}{85}{figure.caption.76}%
\contentsline {figure}{\numberline {5.24}{\ignorespaces Our algorithm processes triangle meshes that can be extracted from different formats: an implicit microstructure geometry from \citep {tozoni2020low} or a subdivision surface from \citep {crane2013conformal}. The bijective map preserved on the surface allows taking advantage of the plethora of surface algorithms including polyhedral geodesic computation \citep {mitchell1987discrete} and texture mapping.\relax }}{86}{figure.caption.77}%
\contentsline {figure}{\numberline {5.25}{\ignorespaces $L^2$ error of the solution of the Poisson equation with respect to model size on our three datasets.\relax }}{86}{figure.caption.78}%
\contentsline {figure}{\numberline {5.26}{\ignorespaces By meshing the region between a box and a complicated obstacle, we are able to perform non-linear fluid simulation on our curved mesh.\relax }}{87}{figure.caption.79}%
\addvspace {10\p@ }
\contentsline {figure}{\numberline {6.1}{\ignorespaces Example of four different mesh editing algorithms implemented with our library. With our framework, users can implement different flavor of mesh editing with built in robustness, and readily available parallelism. From left to right: harmonic triangulation, QSlim, the input, isotropic remeshing, and robust tetrahedral mesh generation. \relax }}{89}{figure.caption.80}%
\contentsline {figure}{\numberline {6.2}{\ignorespaces Overview of the components behind our specification. A mesh is represented trough its topology, implemented by our library, and a list of user provided attributes. Before an operation is attempted, we explicitly perform a pre-check, and, if successful, we generate a mesh (attributes and topology). At this point, we trigger the after check to validate the operation (e.g., check if the newly generate mesh has positive volume). In case the after check fails, we \emph {automatically} rollback the operation and restore the mesh to its previous \emph {valid} state.\relax }}{92}{figure.caption.81}%
\contentsline {figure}{\numberline {6.3}{\ignorespaces Example of the locking region for two edges. In the example the operation requires locking a two-ring neighborhood (e.g., for the edge collapse operation). If the two edges are sufficiently far (right) both operations can be safely executed in parallel. When the two edges are close (left) the operations might fail acquiring the mutexes in the shared area.\relax }}{97}{figure.caption.84}%
\contentsline {figure}{\numberline {6.4}{\ignorespaces Comparison of our parallel implementation (32 threads) of shortest edge collapse (scalability plot on the right, from 1 to 32 threads) of a model with $281,724$ faces with the serial version in libigl. Both libigl and our output have $28,168$ faces and comparable edge length (1.058 for libigl versus 1.061 for ours). Our serial method runs in 4.9s (5.84s on a single thread, 0.52s with 32 thread, leading to a speedup of $11\times $), while libigl runs in 2.74s.\relax }}{100}{figure.caption.87}%
\contentsline {figure}{\numberline {6.5}{\ignorespaces Comparison of our parallel implementation of QSlim with the serial version in libigl for a model with $1,909,755$ faces. Top right, the libigl output has $17,891$ faces and takes 41.26s. Bottom left, our output has $17,906$ faces and runs in 306.59s. Our implementation scales well: 347.59s with one thread and 13.88s with 32 (25$\times $ speedup). \relax }}{101}{figure.caption.88}%
\contentsline {figure}{\numberline {6.6}{\ignorespaces Example of uniform remeshing a model with $2,529,744$ triangles (left) with the same target edge length. Middle, \citep {mobius2010openflipper} remeshes it to $78,322$ faces in 31.96 seconds. On the right is our 32-thread implementation, which generates $71,640$ triangles in 8.2 seconds (78.34s serial, 95.0s for a single thread, leading to a speedup of 11$\times $). The difference in density of the meshes is due to differences in the detail of the implementation, which makes the two methods reach an average vertex valence of 5.999, and a similar target edge length (differ 0.01\% of the bounding box diagonal length) with a different element budget.\relax }}{102}{figure.caption.89}%
\contentsline {figure}{\numberline {6.7}{\ignorespaces Example of \emph {Harmonic Triangulations} starting with one million Gaussian distributed random points. Both our and the reference implementation reach a similar target number of tetrahedra (5.9 million for the reference and 6.1 million for ours, due to a difference in operation ordering) and a similar Mean Harmonic Index (0.547 for the reference and 0.554 for ours). Our method takes 3.82s with 32 threads (15.49s serial, 40.49s on a single thread, speedup of 11$\times $), while the reference serial implementation takes 6.37s.\relax }}{103}{figure.caption.90}%
\contentsline {figure}{\numberline {6.8}{\ignorespaces Tetrahedralize a surface with $856,294$ faces. Original TetWild (top right) generates a mesh with $56,761$ tetrahedra in 287.58s; our reimplementation (bottom left) generates a mesh with $44,866$ tetrahedra in 153.33s with 8 threads (452.42s serial, 521.47s on a single thread, speedup of $3.4\times $). The difference in number of tetrahedra is likely due to the different order of scheduling of operations due to the partitioning.\relax }}{104}{figure.caption.91}%
\contentsline {figure}{\numberline {6.9}{\ignorespaces Example of splitting the longest edge on the bottom of the triangle. On the left, the edge can be split to generate the dark blue edge. In the next iteration, the left edge is split (by the light blue edge) leading to a decreasing maximum edge-length. On the left, the bottom edge is locked illustrated by a dashed line. In this case the next iteration splits the left edge (dark blue edge) and so on. As long as the dashed edge is locked it will never be split preventing the maximum edge length to decrease.\relax }}{105}{figure.caption.92}%
\contentsline {figure}{\numberline {6.10}{\ignorespaces Shortest edge collapse with envelope containment of a model with $857,976$ faces. Our method successfully generates a mesh with $71,298$ faces in 37.49s with 32 threads (731.32s serial, 725.34s on a single thread, speedup of $20\times $).\relax }}{105}{figure.caption.93}%
\contentsline {figure}{\numberline {6.11}{\ignorespaces Uniform remeshing with envelope containment check of a model with $198,918$ faces. Our method produces a mesh with $68,202$ faces in 29.11s with 32 threads and 493.54s for a single thread (483.68s for the serial version) leading to a speedup of 16$\times $.\relax }}{106}{figure.caption.94}%
\contentsline {figure}{\numberline {6.12}{\ignorespaces Timings, target edge length ratio, and valence for every model in the dataset. Most models finish within a minute. The target edge length ratio measure how well our algorithm simplifies the meshes to reach the desired edge length, with an optimal value of 1. Since uniform remeshing strives to generate regular meshes, for most model our algorithm is able to obtain the optimal valence of 6.\relax }}{106}{figure.caption.95}%
\contentsline {figure}{\numberline {6.13}{\ignorespaces Timing, max and average AMIPS energy (capped at 20) for maximum 25 iterations of tetrahedral meshing. Most models finish withing 20 minutes with only a few taking up to a day. Even by limiting the iterations to 25, most models reach an average AMIPS energy lower than 10, with optimal value at 3.\relax }}{107}{figure.caption.96}%
\addvspace {10\p@ }
\addvspace {10\p@ }
\contentsline {figure}{\numberline {A.1}{\ignorespaces Bevel patterns used in the proofs in Appendix\nobreakspace {}\ref {app:bevel} and Appendix\nobreakspace {}\ref {app:singularity}\relax }}{111}{figure.caption.97}%
\addvspace {10\p@ }
\contentsline {figure}{\numberline {B.1}{\ignorespaces Histogram of mean and maximum conformal AMIPS energy\nobreakspace {}\citep {rabinovich2017scalable} of the output of our method and TetGen.\relax }}{116}{figure.caption.98}%
\contentsline {figure}{\numberline {B.2}{\ignorespaces Histogram of output tetrahedra number for TetGen and {our} method. \relax }}{117}{figure.caption.99}%
