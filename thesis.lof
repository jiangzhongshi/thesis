\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\contentsline {figure}{\numberline {3.1}{\ignorespaces A low-quality mesh with boundary conditions (a) is remeshed using our shell (b) to maintain a bijection between the input and the remeshed output. The boundary conditions (arrows in (a)) are then transferred to the high-quality surface (c), and a non-linear elastic deformation is computed on a volumetric mesh created with TetGen (e). The solution is finally transferred back to the original geometry (d). Note that in this application setting both surface and volumetric meshing can be hidden from the user, who directly specifies boundary conditions and analyses the result on the input geometry.\relax }}{4}{figure.caption.8}%
\contentsline {figure}{\numberline {3.2}{\ignorespaces Overview of our algorithm. We start from a triangle mesh, find directions of extrusion, build the shell, and optimize to simplify it.\relax }}{9}{figure.caption.9}%
\contentsline {figure}{\numberline {3.3}{\ignorespaces Example of the top (left, outer) and bottom (right, inner) surface of the prismatic shell.\relax }}{10}{figure.caption.10}%
\contentsline {figure}{\numberline {3.4}{\ignorespaces A prism $\Delta $ (left) is decomposed into 6 tetrahedra (middle, for clarity, we only draw the 3 tetrahedra of the top slab). Each tetrahedron has a constant vector field in its interior (pointing toward the top surface), which is parallel to the only pillar of the prism that contains the point.\relax }}{11}{figure.caption.11}%
\contentsline {figure}{\numberline {3.5}{\ignorespaces A point $p$ (left) is traced through $\mathcal {V}$ inside the top part of the shell. A ray with $p$ as origin and $\mathcal {V}$ as direction is cast inside the orange tetrahedron (middle). The procedure is repeated (on the blue tetrahedron) until the ray hits a point in the middle surface (right).\relax }}{12}{figure.caption.12}%
\contentsline {figure}{\numberline {3.6}{\ignorespaces A 2D illustration for the normal dot product condition. The blue arrows agrees with the background vector field (white arrows), while the red arrows do not agree.\relax }}{12}{figure.caption.13}%
\contentsline {figure}{\numberline {3.7}{\ignorespaces The composition $\mathcal {P}^{-1}_{\mathcal {S}_2}(\mathcal {P}_{\mathcal {S}_1}(x))$ with $x \in \mathcal {S}_1$, of a direct and an inverse projection operator defines a bijection between two sections $\mathcal {S}_1$ and $\mathcal {S}_2$.\relax }}{13}{figure.caption.14}%
\contentsline {figure}{\numberline {3.8}{\ignorespaces The vector field aligned with the pillar edge (orange) has a negative dot product with the green triangle normal; the tetrahedron with this field direction meets the green triangle at the red vertex. As a consequence, the mid-surface is not a section. After topological beveling, the shell becomes valid since the dot product between the green normal and the new pillar (purple) is positive. \relax }}{16}{figure.caption.15}%
\contentsline {figure}{\numberline {3.9}{\ignorespaces The beveling patterns used to decompose prisms for which $\mathcal {T}$ is not a section.\relax }}{16}{figure.caption.16}%
\contentsline {figure}{\numberline {3.10}{\ignorespaces Our algorithm refines the input model (left) with beveling patterns (middle) to ensure the generation of a valid shell. The subsequent shell optimizations gracefully remove the unnecessary vertices (right).\relax }}{17}{figure.caption.17}%
\contentsline {figure}{\numberline {3.11}{\ignorespaces Different local operations used to optimize the shell. Mesh editing operations translate naturally to the shell setting. For vertex smoothing, we decompose the operation into 3 intermediate steps: pan, zoom, and rotate.\relax }}{18}{figure.caption.18}%
\contentsline {figure}{\numberline {3.12}{\ignorespaces A model with 48 singularities and a close up around one (left). Our shell is pinched around each of them without affecting other regions (right).\relax }}{20}{figure.caption.19}%
\contentsline {figure}{\numberline {3.13}{\ignorespaces Left to right: examples of a singularity as a feature point and as a meshing artefact; and illustration of the degenerate prism with a singularity (red) and its tetrahedral decomposition made of only four tetrahedra.\relax }}{21}{figure.caption.21}%
\contentsline {figure}{\numberline {3.14}{\ignorespaces $AA'$ is a direction with positive dot product with respect to all its neighboring faces. However, no valid shell can be built following that direction.\relax }}{22}{figure.caption.22}%
\contentsline {figure}{\numberline {3.15}{\ignorespaces An example of a mesh with boundary.\relax }}{23}{figure.caption.23}%
\contentsline {figure}{\numberline {3.16}{\ignorespaces The effect of different target thickness on the number of prisms |F| of the final shell, and distribution of final thickness (shown as the box plots on the top).\relax }}{23}{figure.caption.24}%
\contentsline {figure}{\numberline {3.17}{\ignorespaces Gallery of shells built around models from Thingi10k \cite {zhou2016thingi10k} and ABC\nobreakspace {}\cite {Koch_2019_CVPR}.\relax }}{24}{figure.caption.25}%
\contentsline {figure}{\numberline {3.18}{\ignorespaces Statistics of 5018 shells in Thingi10k dataset \citep {zhou2016thingi10k} (left) and 5545 in ABC Dataset \citep {Koch_2019_CVPR} (right).\relax }}{25}{figure.caption.26}%
\contentsline {figure}{\numberline {3.19}{\ignorespaces The \emph {UV based method} cannot simplify the prescribed seams, and introduces self-intersections. The projection induced by the \emph {Naive Cage} method is not continuous and not bijective; it leads to visible spikes in the reconstructed geometry.\relax }}{26}{figure.caption.27}%
\contentsline {figure}{\numberline {3.20}{\ignorespaces Our projection is three orders of magnitude more accurate than the baseline method, and bijectively reconstructs the input vertex coordinates.\relax }}{27}{figure.caption.28}%
\contentsline {figure}{\numberline {3.21}{\ignorespaces We attempt to simplify \emph {rockerarm} (top left) from 20088 triangles to 100. QSlim\nobreakspace {}\citep {garland1998simplifying} succeeds in reaching the target triangle count (top right) but generates an output with a self-intersection (red) and flipped triangles (purple). With our shell constraints (bottom left), the simplification stagnates at 136 triangles, but the output is free from undesirable geometric configurations. Note that both examples use the same quadratic error metric based sceduling\nobreakspace {}\citep {garland1998simplifying}. \relax }}{28}{figure.caption.29}%
\contentsline {figure}{\numberline {3.22}{\ignorespaces The heat method (right top) produces inaccurate results due to a poor triangulation (left top). We remesh the input with our method (left bottom), compute the solution of the heat method\nobreakspace {}\citep {crane2013geodesics} on the high-quality mesh (middle bottom) and transfer the solution back to the input mesh using the bijective projection (bottom right). This process produces a result closer to the exact discrete geodesic distance \citep {mitchell1987discrete} (top middle, error shown in the histograms).\relax }}{29}{figure.caption.30}%
\contentsline {figure}{\numberline {3.23}{\ignorespaces \emph {Knot} simplified with our method and tetrahedralized with TetGen. The original model is converted to 1,503,428 tetrahedra (left) while the simplified surface is converted to only 176,190 tetrahedra (right).\relax }}{30}{figure.caption.31}%
\contentsline {figure}{\numberline {3.24}{\ignorespaces The union of two meshes is coarsened through our algorithm, while preserving the exact correspondence, as shown through color transfer.\relax }}{31}{figure.caption.32}%
\contentsline {figure}{\numberline {3.25}{\ignorespaces Top: an input mesh decimated to create a coarse base mesh, and the details are encoded in a displacement map (along the normal) with correspondences computed with Phong projection \citep {kobbelt1998interactive}. Bottom: the decimation is done within our shell while using the same projection as above. With our construction, this projection becomes bijective (Appendix \ref {app:bilinear}), avoiding the artifacts visible on the ears of the bunny in the top row.\relax }}{32}{figure.caption.33}%
\contentsline {figure}{\numberline {3.26}{\ignorespaces Two volumetric chainmail textures (right) are applied to a shell (bottom left) constructed from the \emph {Animal} mesh (top left). The original UV coordinates are transferred using our projection operator.\relax }}{32}{figure.caption.34}%
\contentsline {figure}{\numberline {3.27}{\ignorespaces An example of a shell built around a self-intersecting mesh.\relax }}{33}{figure.caption.35}%
\contentsline {figure}{\numberline {3.28}{\ignorespaces The \emph {Armadillo} model with four nested cages. We create a shell from the original mesh, and then rerun our algorithm on the outer shell to create the other three layers. Note that all layers are free of self-intersections, and we have an explicit bijective map between them.\relax }}{33}{figure.caption.36}%
\contentsline {figure}{\numberline {3.29}{\ignorespaces After optimization, the shell may self-intersect (left). Our postprocessing can be used to extract a non-selfintersecting shell, which is easier to use in downstream applications (right).\relax }}{34}{figure.caption.37}%
\contentsline {figure}{\numberline {3.30}{\ignorespaces We generate a pinched shell for a model with a singularity (left). Optionally, we can complete the shell using our Boolean construction.\relax }}{34}{figure.caption.38}%
\addvspace {10\p@ }
\contentsline {figure}{\numberline {4.1}{\ignorespaces Our pipeline starts from a dense \emph {linear} mesh with annotated features (green), which is converted in a curved shell filled with a high-order mesh. The region bounded by the shell is then tetrahedralized with linear elements, which are then optimized. Our output is a coarse, yet accurate, curved tetrahedral mesh ready to be used in FEM based simulation. Our construction provides a bijective map between the input surface and the boundary of the output tetrahedral mesh, which can be used to transfer attributes and boundary conditions.\relax }}{37}{figure.caption.39}%
\contentsline {figure}{\numberline {4.2}{\ignorespaces Input triangle mesh $\mathcal {M}$ and points $\mathcal {P}$. Output curved tetrahedral mesh $\mathcal {T}^k$ and bijective map $\phi ^k$.\relax }}{44}{figure.caption.40}%
\contentsline {figure}{\numberline {4.3}{\ignorespaces Lagrange nodes on the reference element $\hat \tau $ for different $k=1,2,3$ and example of geometric mapping $g$.\relax }}{44}{figure.caption.41}%
\contentsline {figure}{\numberline {4.4}{\ignorespaces Effect of the choice of the set $\mathcal {P}$ on the output.\relax }}{45}{figure.caption.42}%
\contentsline {figure}{\numberline {4.5}{\ignorespaces Our algorithm maintains {free of} intersection even on challenging models, without the need of setting adaptive threshold.\relax }}{46}{figure.caption.43}%
\contentsline {figure}{\numberline {4.6}{\ignorespaces Overview of curved mesh generation pipeline.\relax }}{46}{figure.caption.44}%
\contentsline {figure}{\numberline {4.7}{\ignorespaces A model simplified with different distances.\relax }}{48}{figure.caption.45}%
\contentsline {figure}{\numberline {4.8}{\ignorespaces Two dimensional overview of the five steps of our boundary preserving tetrahedral meshing algorithm.\relax }}{49}{figure.caption.46}%
\contentsline {figure}{\numberline {4.9}{\ignorespaces Input triangle mesh with features and output curved mesh with feature preserved equipped with bijective map $\phi ^k$.\relax }}{51}{figure.caption.47}%
\contentsline {figure}{\numberline {4.10}{\ignorespaces A sphere with different marked features (green). As we increase the number of features our algorithm will preserve them all but the quality of the surface suffers.\relax }}{52}{figure.caption.48}%
\contentsline {figure}{\numberline {4.11}{\ignorespaces Input feature (green) is not preserved after traditional shell simplification.\relax }}{52}{figure.caption.49}%
\contentsline {figure}{\numberline {4.12}{\ignorespaces Overview of the construction of the first stage of our pipeline.\relax }}{52}{figure.caption.50}%
\contentsline {figure}{\numberline {4.13}{\ignorespaces The input mesh has feature edges snapped, to create a valid shell, as well as the curved mesh.\relax }}{53}{figure.caption.51}%
\contentsline {figure}{\numberline {4.14}{\ignorespaces The input edges feature (green) are grouped together in poly-lines and categorized in graph (left) and loops (right). For every graph we add the nodes (blue) to the set of feature vertices.\relax }}{53}{figure.caption.52}%
\contentsline {figure}{\numberline {4.15}{\ignorespaces Illustration of smoothing on a feature.\relax }}{54}{figure.caption.53}%
\contentsline {figure}{\numberline {4.16}{\ignorespaces Curved meshes of different order. The additional degrees of freedom allows for more coarsening.\relax }}{55}{figure.caption.54}%
\contentsline {figure}{\numberline {4.17}{\ignorespaces Relative average edge length (with respect to longest bounding box edge of each model) of our curved meshes versus number of input vertices.\relax }}{56}{figure.caption.55}%
\contentsline {figure}{\numberline {4.18}{\ignorespaces Within the same distance bound ($10^{-3}$ of the longest bounding box side), our method generates a coarser high order mesh, compared to the linear counterpart generated by fTetWild.\relax }}{56}{figure.caption.56}%
\contentsline {figure}{\numberline {4.19}{\ignorespaces Surface and volume average MIPS energy of the output of our method (the CAD volume energy is truncated at 100, excluding 6 models).\relax }}{57}{figure.caption.57}%
\contentsline {figure}{\numberline {4.20}{\ignorespaces Timing of our algorithm versus the input number of vertices.\relax }}{57}{figure.caption.58}%
\contentsline {figure}{\numberline {4.21}{\ignorespaces Compared with Curved ODT, our method does not rely on setting vertex number and sizing field, and can generate coarse valid results.\relax }}{58}{figure.caption.59}%
\contentsline {figure}{\numberline {4.22}{\ignorespaces Example of a BRep meshed with Gmsh where the optimization fails to untangle elements when fixing the surface. By allowing the surface to be modified, the mesh becomes ``wiggly''. Our method successfully generate a positive curved mesh.\relax }}{59}{figure.caption.60}%
\contentsline {figure}{\numberline {4.23}{\ignorespaces Example of a STEP file meshed with Gmsh where, due to the low mesh density, the tetrahedralization is not positive. Gmsh manages to generate a positive mesh by using a denser initial tessellation. Since our method starts from a dense mesh and coarsen it, it can successfully resolve the geometry.\relax }}{59}{figure.caption.61}%
\contentsline {figure}{\numberline {4.24}{\ignorespaces Our algorithm processes triangle meshes that can be extracted from different formats: an implicit microstructure geometry from \citep {tozoni2020low} or a subdivision surface from \citep {crane2013conformal}. The bijective map preserved on the surface allows taking advantage of the plethora of surface algorithms including polyhedral geodesic computation \citep {mitchell1987discrete} and texture mapping.\relax }}{60}{figure.caption.62}%
\contentsline {figure}{\numberline {4.25}{\ignorespaces $L^2$ error of the solution of the Poisson equation with respect to model size on our three datasets.\relax }}{60}{figure.caption.63}%
\contentsline {figure}{\numberline {4.26}{\ignorespaces By meshing the region between a box and a complicated obstacle, we are able to perform non-linear fluid simulation on our curved mesh.\relax }}{61}{figure.caption.64}%
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
