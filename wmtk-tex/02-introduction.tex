
\begin{figure}
    \centering\footnotesize
    \includegraphics[width=\linewidth]{wmtk-tex/figs/teaser2.pdf}
    \caption{\revision{Example of four different mesh editing algorithms implemented with our library. With our framework, users can implement different flavor of mesh editing with built in robustness, and readily available parallelism. From left to right: harmonic triangulation, QSlim, the input, isotropic remeshing, and robust tetrahedral mesh generation. }}
    \label{wmtk:fig:teaser}
\end{figure}

\section{Introduction}

Unstructured triangular and tetrahedral meshes are widely used in graphics, engineering, and scientific computing due to their flexibility to represent objects with complex boundaries. Such unstructured meshes find their usage in modeling and rendering 3D objects and scenes, discretizing partial differential equations for physical simulation,  collisions detection and response, path planning in robotics, and many other applications.

\revision{An unstructured} mesh is usually stored in a custom data-structure supporting a set of local operations to add, remove, or change its elements and their properties. A major research effort has been invested in exploring different data-structures and evaluating their generality and efficiency (Section \ref{wmtk:sec:related}), which led to the development of mesh libraries such as CGAL \cite{cgal2008computational}, VCG/meshlab \cite{vcg}, OpenMesh \cite{botsch2002openmesh}, libigl \cite{jacobson2016libigl}, PMP \cite{pmp-library}, and OpenVolumeMesh \cite{kremer2013openvolumemesh}.
Commonly, mesh-editing algorithms are tightly coupled with a data-structure and its API, and porting an algorithm from one library to another is a major engineering effort. 
Code relying on local operations is also inherently error prone, as it usually involves keeping track of properties attached to mesh elements as the mesh itself changes due to the local operations. Parallelizing code using a mesh data structure is also challenging, due to race conditions when multiple threads attempt to change the same region of the mesh. 

At a high-level, it is common practice to describe a mesh editing algorithm as a sequence of topological and geometrical editing operations. We argue that this approach is unnecessarily low-level, as it exposes the algorithm designer to technical problems that can be handled automatically by changing the abstraction level. It also makes it challenging to use or customize mesh editing algorithms in larger projects (such as their use in physical simulation for adaptive refinement), as low-level data structure details percolate in the entire code-base. 
\revision{A particularly difficult challenge in these algorithms is to ensure that a set of conditions (such as manifoldness, being free from self-intersections, minimal quality, maximal geometrical approximation) hold after each operation is applied. This is usually tackled by simulating each operation for the purpose of checking these conditions, an error-prone process that needs to be carefully designed for each pair of operation and condition. The additional presence of attributes attached to vertices, edges, or faces further complicates these problems.}

We propose a different way to describe mesh-editing algorithms on simplicial manifold meshes, using a declarative specification instead of a more traditional procedural approach. Instead of focusing on what the algorithm does, we ask the user to specify what are the requirements that the desired mesh should have. We divide these requirements into two groups: invariants and desiderata. The former is a description of hard requirements on the mesh (for example, no inverted elements or no self-intersections) and the latter is a set desirable properties (such as good quality). A mesh editing algorithm is then described as: (1) a set of per-element invariants (for example, all elements should have correct orientation), (2) a measure for the desiderata (for example, element quality), (3) a set of application-specific attributes attached to mesh elements, and how they are affected by local operations, and (4) a schedule of operation types. We show that many existing algorithms for mesh generation, remeshing, and parametrization, can be concisely expressed in this form (Section \ref{wmtk:sec:applications}), which we denote IDAS (Invariant-Desiderata-Attributes-Schedule).

The IDAS specification has been designed with four goals:
\begin{enumerate}
    \item \textbf{Modularity:} The connectivity of the mesh is abstracted from the user, which can only navigate the mesh using a high-level abstraction based on a cell tuple \cite{Brisson1989}. This reduces the learning curve for a new user, as they only need to learn a navigation API to implement algorithms in IDAS. It will also allow IDAS programs to benefit from continuous progress in data-structure design, as the data structure will be swappable without requiring downstream code changes in the high level IDAS code. This is in stark contrast with existing mesh libraries, which tend to be very invasive in the user code relying on them due to the close connection between navigation, mesh editing, and property management.
    \item \textbf{Usability:} The user code sees, at all times, a valid mesh: the library simulates each operation transparently allowing the user to navigate on a valid mesh before and after every operation, dramatically simplifying the logic required to define invariants and desiderata. Properties on the mesh are also similarly abstracted, allowing to attach attributes on every simplex independently on the data structure used for implementing the specification.
    \item \textbf{Efficiency:} The specification purposely requires only definitions of properties on individual elements. This feature allows runtimes for IDAS program to  parallelize the computation (Section \ref{wmtk:sec:applications}) without requiring special attention from an user. We demonstrate that automatic parallelization of mesh editing algorithms is possible on multi-core architectures.
    \item \textbf{Robustness:} The IDAS specification moves the majority of the robustness issues typical of meshing algorithm on the runtime used to execute a IDAS program instead of the IDAS code itself. This simplifies the development of robust algorithms: for example, the user invariants are guaranteed to be enforced during processing, as the runtime will automatically check them on every modified element. As long as the user provides correct code for the invariant (for example to check for area positivity of an element using a predicate), then the runtime ensures that the invariants will be satisfied for all elements.
\end{enumerate}

Given an algorithm in IDAS form, we design an algorithm and runtime library to realize it, with guarantees on satisfying the invariant and a best effort to maximize the desiderata. Our library exploits shared memory parallelism without any additional effort required from users in the algorithm specification. 

To demonstrate the generality and effectiveness of our approach, we provide IDAS formulations for five popular mesh editing algorithms (Section \ref{wmtk:sec:applications}, Figure~\ref{wmtk:fig:teaser}): (1) shortest edge collapse \cite{hoppe1996progressive} (decimation for triangle meshes), (2) \revision{QSlim} \cite{garland1997surface}, (3) isotropic triangle meshing \cite{botsch2004remeshing} (remeshing for triangle meshes), (4) harmonic triangulations \cite{Alexa:2019} (quality improvement for 3D volumes), and (5) robust tetrahedral mesh generation \cite{Hu:2019:fTetWild} (conversion of surface meshes to volumetric meshes). 
The IDAS formulation closely resemble the textual description of the algorithms in the corresponding papers: it is compact, readable, and easy to adapt for requirements of specific applications. As an example, we show that modifying (1) and (2) to guarantee a maximal geometric error requires is straightforward. Despite its generality, IDAS implementations executed using our library are comparable or faster than state of the art implementations in open-source software: the overhead due to the framework generality is more than compensated by the automatic parallelization (Section \ref{wmtk:sec:applications}).

We believe our contribution is an important step to allow researchers and practitioners to effectively develop new mesh-editing algorithms, shielding the designer of mesh editing algorithms from many of the robustness and correctness challenges plaguing previous low-level approaches, by moving these components inside the runtime environment. It will also allow mesh editing algorithms to be used more easily in larger systems, as they can be tailored to requirements of a specific application with minimal programming effort.

We provide an open-source implementation of our library and of the five mesh editing algorithms as additional material.

